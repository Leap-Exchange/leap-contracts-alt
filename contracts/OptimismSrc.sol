// SPDX-License-Identifier: MIT
// pragma solidity >0.6.11 <0.8.12;
pragma solidity ^0.8.0;
pragma experimental ABIEncoderV2;

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/utils/math/SafeMath.sol';
import './utils/Data.sol';

// [TODO]
// import openzeppelin ERC20 Interface so we can use ERC20 token functions

contract Source {
  using SafeMath for uint256;

  address public owner;
  uint256 public CONTRACT_FEE_BASIS_POINTS;
  // TODO: Better indexing of transferhashes for UI? 
  mapping(bytes32 => bool) public validTransferHashes;
  bytes32 processedRewardHashOnion;
  uint256 public nextTransferID;
  // reward hash onions sent from destination side
  mapping(bytes32 => bool) knownHashOnions;
  uint256 public lastSourceHeadPosition;
  // tx states


  modifier restricted() {
    require(
      msg.sender == owner,
      "This function is restricted to the contract's owner"
    );
    _;
  }

  constructor(){
    owner = msg.sender;
    CONTRACT_FEE_BASIS_POINTS = 100; // LP gets 1% fee for now.
    processedRewardHashOnion = keccak256(abi.encodePacked('0'));
    knownHashOnions[keccak256(abi.encodePacked('0'))] = true;
    lastSourceHeadPosition = 0;
    nextTransferID = 0;
  }

  event TransferInitiated(Data.TransferData transfer, uint256 transferID);

  function transfer(Data.TransferData memory transferData) public payable {
    // improve hashing implementation - optimize for least gas usage. For now, the following will have to do
    require(transferData.destination != address(0), 'cannot send tokens to black hole address'); 
    bytes32 transferHash = keccak256(abi.encodePacked(abi.encode(transferData), nextTransferID));
    require(!validTransferHashes[transferHash], 'transfer hash collision'); // error message change?
    uint256 amountPlusFee = transferData.amount.mul(10000 + CONTRACT_FEE_BASIS_POINTS).div(10000); 
    if (transferData.srcTokenAddress != address(0))
    {
      IERC20(transferData.srcTokenAddress).transferFrom(msg.sender, address(this), amountPlusFee);
    } 
   else{
      // Transfer ether here -> with
      require(msg.value >= 0.001 ether, 'minimum ether required is 0.001 ether');
      require(msg.value == amountPlusFee, 'insufficient ether provided');
    }
    validTransferHashes[transferHash] = true;
    emit TransferInitiated(transferData, nextTransferID); 
    nextTransferID++;
  }


  function processClaims(bytes32[] memory rewardList) public { // can only be called by Optimism Messenger
    // Verify that the new hash onion head generated by applying the claims to the current processedRewardHashOnion in knownHashOnions
    require(rewardList[lastSourceHeadPosition] == processedRewardHashOnion);
    for(uint i = 0; i<rewardList.length; i++){
      if (validTransferHashes[rewardList[i].transferDataHash]){
        Data.RewardData memory rewardData = rewardList[i];
        IERC20(rewardData.srcTokenAddress).transferFrom(msg.sender, address(this), rewardData.fee);
      }
    }
    

  }

  // fallback function
  fallback() external{
  }

  function changeOwner(address newOwner) public restricted { 
    require(owner != address(0), '0x0 address cannot be set as the owner!');
    require(owner != newOwner, 'this address is already the owner of the contract');
    owner = newOwner;
  }

}
