// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;
pragma experimental ABIEncoderV2;

import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import './utils/Data.sol';

// [TODO]
// import openzeppelin ERC20 Interface so we can use ERC20 token functions

contract Source {
  address public owner;
  uint public CONTRACT_FEE_BASIS_POINTS;
  // TODO: Better indexing of transferhashes for UI? 
  mapping(bytes32 => bool) public validTransferHashes;
  bytes32 processedRewardHashOnion;
  mapping(bytes32 => bool) knownHashOnions;
  uint256 public lastSourceHeadPosition;
  uint256 public nextTransferID;
  // tx states


  modifier restricted() {
    require(
      msg.sender == owner,
      "This function is restricted to the contract's owner"
    );
    _;
  }

  constructor(){
    owner = msg.sender;
    CONTRACT_FEE_BASIS_POINTS = 5;
    processedRewardHashOnion = keccak256(abi.encodePacked('0'));
    knownHashOnions[keccak256(abi.encodePacked('0'))] = true;
    lastSourceHeadPosition = 0;
    nextTransferID = 0;
  }

  event TransferInitiated(Data.TransferData transfer, uint256 transferID);

  function transfer(Data.TransferData memory transferData) public payable {
    // improve hashing implementation - optimize for least gas usage. For now, the following will have to do
    bytes32 transferHash = keccak256(abi.encodePacked(abi.encode(transferData), nextTransferID));
    require(!validTransferHashes[transferHash], 'this transfer '); // error message change?
    uint256 amountPlusFee = (transferData.amount * (10000 + CONTRACT_FEE_BASIS_POINTS)) / 10000; // 0.05% fee
    if (transferData.srcTokenAddress != address(0))
    {
      IERC20(transferData.srcTokenAddress).transferFrom(msg.sender, address(this), amountPlusFee);
    } 
   else{
      // Transfer ether here
      require(msg.value >= 0.001 ether, 'minimum ether required is 0.001 ether');
      require(msg.value == amountPlusFee, 'insufficient ether provided');
    }
    validTransferHashes[transferHash] = true;
    emit TransferInitiated(transferData, nextTransferID); 
    nextTransferID++;
 }

  function processClaims(Data.RewardData[] memory rewardList) public{
    // Verify that the new hash onion head generated by applying the claims to the current processedRewardHashOnion in knownHashOnions
    require(rewardList[lastSourceHeadPosition] == processedRewardHashOnion);
    for(uint i = 0; i<rewardList.length; i++){
      if (validTransferHashes[rewardList[i].transferDataHash]){
        Data.RewardData  memory rewardData = rewardList[i];
        IERC20(rewardData.srcTokenAddress).transferFrom(msg.sender, address(this), rewardData.fee);
      }
    }
    

  }

  // fallback function
  fallback() external{
  }

  function changeOwner(address newOwner) public restricted { 
    require(owner != address(0), '0x0 address cannot be set as the owner!');
    require(owner != newOwner, 'this address is already the owner of the contract');
    owner = newOwner;
  }

}
